package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"strings"

	core "github.com/textileio/go-threads/core/store"
	"github.com/textileio/go-threads/store"
)

var (
	jsonSchema = `{
		"$schema": "http://json-schema.org/draft-04/schema#",
		"$ref": "#/definitions/book",
		"definitions": {
		   "book": {
			  "required": [
				 "ID",
				 "Title",
				 "Author",
				 "Meta"
			  ],
			  "properties": {
				 "Author": {
					"type": "string"
				 },
				 "ID": {
					"type": "string"
				 },
				 "Meta": {
					"$schema": "http://json-schema.org/draft-04/schema#",
					"$ref": "#/definitions/bookStats"
				 },
				 "Title": {
					"type": "string"
				 }
			  },
			  "additionalProperties": false,
			  "type": "object"
		   },
		   "bookStats": {
			  "required": [
				 "TotalReads",
				 "Rating"
			  ],
			  "properties": {
				 "Rating": {
					"type": "number"
				 },
				 "TotalReads": {
					"type": "integer"
				 }
			  },
			  "additionalProperties": false,
			  "type": "object"
		   }
		}
	 }`
)

func main() {
	s, clean := createJsonModeMemStore()
	defer clean()

	model, err := s.RegisterSchema("Book", jsonSchema)
	checkErr(err)

	// Bootstrap the model with some books: two from Author1 and one from Author2
	{
		// Create a two books for Author1
		book1 := `{"ID": "", "Title": "Title1", "Author": "Author1", "Meta": { "TotalReads": 100, "Rating": 3.2 }}` // Notice ID will be autogenerated
		book2 := `{"ID": "", "Title": "Title2", "Author": "Author1", "Meta": { "TotalReads": 150, "Rating": 4.1 }}`
		checkErr(model.Create(&book1, &book2)) // Note you can create multiple books at the same time (variadic)

		// Notice you can see here that the Store has filled the autogenerated id *in the same instance*!
		fmt.Printf("After creation Book1: %s\n", book1)
		fmt.Printf("After creation Book2: %s\n", book2)

		// Raw json editing :)
		editedBook2 := strings.ReplaceAll(book2, "150", "100000")
		checkErr(model.Save(&editedBook2))

		idxStart := strings.Index(book2, `"ID":"`)
		id := book2[idxStart+6 : idxStart+6+36] // Fast way of getting generated ID
		entityID := core.EntityID(id)

		// Try .Has(...)
		exists, err := model.Has(entityID)
		checkErr(err)
		if !exists {
			panic("instance should exist")
		}

		// Try getting it by ID
		var foundEditedBook2 string
		checkErr(model.FindByID(entityID, &foundEditedBook2))
		fmt.Printf("Book2 after edition: %s\n", foundEditedBook2)
		if !strings.Contains(foundEditedBook2, "100000") {
			panic("book2 doesn't have updated information")
		}

		checkErr(model.Delete(entityID))

		exists, err = model.Has(entityID)
		checkErr(err)
		if exists {
			panic("instance shouldn't exist")
		}
	}
}

func createJsonModeMemStore() (*store.Store, func()) {
	dir, err := ioutil.TempDir("", "")
	checkErr(err)
	ts, err := store.DefaultService(dir)
	checkErr(err)
	s, err := store.NewStore(ts, store.WithRepoPath(dir), store.WithJsonMode(true))
	checkErr(err)
	return s, func() {
		if err := ts.Close(); err != nil {
			panic(err)
		}
		_ = os.RemoveAll(dir)
	}
}

func checkErr(err error) {
	if err != nil {
		panic(err)
	}
}
