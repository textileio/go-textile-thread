package main

import (
	"context"
	"fmt"
	"io/ioutil"
	"os"
	"strings"
	"time"

	core "github.com/textileio/go-threads/core/db"
	"github.com/textileio/go-threads/core/thread"
	"github.com/textileio/go-threads/db"
)

var (
	jsonSchema = `{
		"$schema": "http://json-schema.org/draft-04/schema#",
		"$ref": "#/definitions/book",
		"definitions": {
		   "book": {
			  "required": [
				 "ID",
				 "Title",
				 "Author",
				 "Meta"
			  ],
			  "properties": {
				 "Author": {
					"type": "string"
				 },
				 "ID": {
					"type": "string"
				 },
				 "Meta": {
					"$schema": "http://json-schema.org/draft-04/schema#",
					"$ref": "#/definitions/bookStats"
				 },
				 "Title": {
					"type": "string"
				 }
			  },
			  "additionalProperties": false,
			  "type": "object"
		   },
		   "bookStats": {
			  "required": [
				 "TotalReads",
				 "Rating"
			  ],
			  "properties": {
				 "Rating": {
					"type": "number"
				 },
				 "TotalReads": {
					"type": "integer"
				 }
			  },
			  "additionalProperties": false,
			  "type": "object"
		   }
		}
	 }`
)

func main() {
	d, clean := createJsonModeMemDB()
	defer clean()

	collection, err := d.NewCollection(db.CollectionConfig{Name: "Book", Schema: jsonSchema})
	checkErr(err)

	// Bootstrap the collection with some books: two from Author1 and one from Author2
	{
		// Create a two books for Author1
		book1 := `{"ID": "", "Title": "Title1", "Author": "Author1", "Meta": { "TotalReads": 100, "Rating": 3.2 }}` // Notice ID will be autogenerated
		book2 := `{"ID": "", "Title": "Title2", "Author": "Author1", "Meta": { "TotalReads": 150, "Rating": 4.1 }}`
		checkErr(collection.Create(&book1, &book2)) // Note you can create multiple books at the same time (variadic)

		// Notice you can see here that the DB has filled the autogenerated id *in the same instance*!
		fmt.Printf("After creation Book1: %s\n", book1)
		fmt.Printf("After creation Book2: %s\n", book2)

		// Raw json editing :)
		editedBook2 := strings.ReplaceAll(book2, "150", "100000")
		checkErr(collection.Save(&editedBook2))

		idxStart := strings.Index(book2, `"ID":"`)
		id := book2[idxStart+6 : idxStart+6+36] // Fast way of getting generated ID
		instanceID := core.InstanceID(id)

		// Try .Has(...)
		exists, err := collection.Has(instanceID)
		checkErr(err)
		if !exists {
			panic("instance should exist")
		}

		// Try getting it by ID
		var foundEditedBook2 string
		checkErr(collection.FindByID(instanceID, &foundEditedBook2))
		fmt.Printf("Book2 after edition: %s\n", foundEditedBook2)
		if !strings.Contains(foundEditedBook2, "100000") {
			panic("book2 doesn't have updated information")
		}

		checkErr(collection.Delete(instanceID))

		exists, err = collection.Has(instanceID)
		checkErr(err)
		if exists {
			panic("instance shouldn't exist")
		}
	}
}

func createJsonModeMemDB() (*db.DB, func()) {
	dir, err := ioutil.TempDir("", "")
	checkErr(err)
	ts, err := db.DefaultService(dir)
	checkErr(err)
	id := thread.NewIDV1(thread.Raw, 32)
	d, err := db.NewDB(context.Background(), ts, id, db.WithRepoPath(dir), db.WithJsonMode(true))
	checkErr(err)
	return d, func() {
		time.Sleep(time.Second) // Give threads a chance to finish work
		if err := ts.Close(); err != nil {
			panic(err)
		}
		_ = os.RemoveAll(dir)
	}
}

func checkErr(err error) {
	if err != nil {
		panic(err)
	}
}
